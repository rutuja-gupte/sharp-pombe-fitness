---
title: "MA Fitness"
author: "Rutuja Gupte"
date: "2023-09-21"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

---
title: "MA Fitness"
author: "Dr Nathaniel Sharp"
---

- this fits a spline to y=OD versus x=time, and then finds the maximum slope
```{r}
# spline.slope<-function(x, y, n=101, eps=1e-5, span=0.2){
#   max(nderiv(loess(log(y) ~ x, degree=1, span=span), seq(min(x), max(x), length=n)), na.rm=TRUE)
# }

spline.slope<-function(x, y, n=101, eps=1e-5, span=0.2){
  max(nderiv(loess(log(y) ~ x, degree=1, span=span), x), na.rm=TRUE)
}
```

- used by the function above to get a local (linear) slope around a point

```{r}
nderiv <- function(fit, x, eps=1e-5){
  (predict(fit, x + eps) - predict(fit, x - eps))/(2 * eps)}

```

---
title: "MA Fitness"
author: "Rutuja Gupte"
---

Import Statements
```{r}
library(dplyr)
library(stringr)
library(tidyverse)
library(lme4)
# lib vioplot for violin plot
library(vioplot)
```

Preliminary work to find the time stamp for the max slope
```{r}
assay <- read.delim("Rutuja 05 05.txt")
ref <- read.csv("Ref 05 05.csv")
assay$Time<-seq(from=0.25,by=0.25,length.out=nrow(assay))
  # calculate slopes
ref$slope <- sapply(c(1:nrow(ref)), function(r){
    spline.slope(assay$Time, assay[,which(names(assay)==ref$well[r])])
  })

y <- assay$J15
x <- assay$Time

# loess gives a smooth version of the curve
ess <- loess(log(y) ~ x, degree=1, span=0.2)
p <- predict(ess, x)

ggplot() +
  geom_point(aes(y=log(y), x=x)) +
  geom_point(aes(y=p, x=x), color='red') +
  geom_line(aes(y=p, x=x), color='blue')

# calculating the slope of all points using their adjacent points
slopes <- sapply(c(2:(nrow(assay)-1)), function(r){
  (p[r+1]-p[r-1]) / (x[r+1]-x[r-1])
})
ggplot() + geom_point(aes(x=x[2:(length(x)-1)], y=slopes))

# Using the values predicted by loess and nderiv to calculate the slope
slopes2 <- nderiv(ess, x)
ggplot() + geom_point(aes(x=x, y=slopes2), color='red', alpha=0.3) +
  geom_point(aes(x=x[2:(length(x)-1)], y=slopes), color='blue', alpha=0.3)

max(slopes2, na.rm=TRUE)
which.max(slopes2)
slopes2[89]

# spline.time(x,y)
```

> Spline fitting:

First we start by converting everything to log scale. During the exponential growth phase, log(N) is proportional to t where N is the population and t is time. There is noise in the original data. We remove the noise and try to obtain the underlying curve using loess. It gives a smooth curve. Then we use that curve to find local slopes. nderiv gives precise slope of the local linear slope at every point.

- this fits a spline to y=OD versus x=time, and then finds the time-stamp for maximum slope

```{r}
spline.time<-function(x, y, n=101, eps=1e-5, span=0.2){
  estimates <- loess(log(y) ~ x, degree=1, span=span)
  slopes <- nderiv(estimates, x)
  return(which.max(slopes))
}
```


Load all files and setup variables
```{r}
l <- list.files()

# read all data into a list of data frames
dfs <- lapply(l[endsWith(l, '.csv')], function(r){
  d <- read.csv(r)
  
  assay.name <- str_replace(str_replace(r, 'Ref', 'Rutuja'), '.csv', '.txt')
  assay.data <- read.delim(assay.name)
  
  # Change time column to 0, 0.25, 0.5, ...
  assay.data$Time<-seq(from=0.25,by=0.25,length.out=nrow(assay.data))
  # calculate slopes
  d$slope <- sapply(c(1:nrow(d)), function(r){
    spline.slope(assay.data$Time, assay.data[,which(names(assay.data)==d$well[r])])
  })
  
  d$initial <- sapply(c(1:nrow(d)), function(r){
    mean(assay.data[,which(names(assay.data)==d$well[r])][1:4])
  })
  
  d$final <- sapply(c(1:nrow(d)), function(r){
    temp <- assay.data[,which(names(assay.data)==d$well[r])]
    temp <- temp[!is.na(temp)]
     n <- length(temp)
    mean(assay.data[,which(names(assay.data)==d$well[r])][n-3:n])
  })
  
  d$time <- sapply(c(1:nrow(d)), function(r){
    spline.time(assay.data$Time, assay.data[,which(names(assay.data)==d$well[r])])
  })
  
  d$date <- mdy(str_replace(str_replace(r, 'Ref ', ''), '.csv', ' 2023'))
  return(d)
})

# merge the list of data frames
d <- dfs %>% reduce(bind_rows)

dates.1 <- seq(mdy(04062023), mdy(04102023), 1)
dates.2 <- seq(mdy(04282023), mdy(05052023), 1)
# dates.2 <- c(dates.2, mdy(11022023))
ancestors <- c('H1', 'H2', 'H3', 'D1', 'D2', 'D3')
# these are all the haploid ancestors including the diploids that are supposed to be diploids
ancestors.haploid <- c('H1', 'H2', 'H3', 'D2', 'D3')
# these are haploids that were intended to be haploids
anc.hap.og <- c('H1', 'H2', 'H3')
# these are haploids that were intended to be diploids
anc.hap.fake <- c('D2', 'D3')
# this is the only actual diploid control that was diploid
ancestors.diploid <- c('D1')
# this MA line started out as a haploid but ended up as a diploid
fake.haploids <- c(81)
# these MA lines started out as diploids but ended up as haploids
fake.diploids <- c(20, 28, 48, 52, 54, 84, 100)
```

Adding additional information for categorization. Excluding MA lines that changed ploidy. Excluding batch 1 due to lack of diploid controls.
```{r}
d$batch[d$date %in% dates.1] <- 1
d$batch[d$date %in% dates.2] <- 2
d$label <- d$treatment
d$label[d$treatment == 'Blank'] <- '0'
d$label[d$treatment == 'H1'] <- '101'
d$label[d$treatment == 'D1'] <- '102'
d$label[d$treatment == 'H2'] <- '103'
d$label[d$treatment == 'D2'] <- '104'
d$label[d$treatment == 'H3'] <- '105'
d$label[d$treatment == 'D3'] <- '106'
d$label[d$treatment == 'C1'] <- '107'
d$label[d$treatment == 'C3'] <- '109'
d$label <- as.numeric(d$label)

d <- d %>% mutate(category = case_when(label == 0 ~ 'Blank',
                              label > 100 & treatment %in% ancestors.haploid ~ 'Ctrl.H',
                              label > 100 & treatment %in% ancestors.diploid ~ 'Ctrl.D',
                              label %% 2 == 0 ~ 'MA.D',
                              label %% 2 == 1 ~ 'MA.H'))


d <- d %>% mutate(category = ifelse(label %in% fake.diploids, 'MA.H', category))
d <- d %>% mutate(category = ifelse(label %in% fake.haploids, 'MA.D', category))

d <- d %>% filter(batch == 2)
```


Use dates before taking average to check for day effects
```{r}
# d %>% ggplot() + geom_point(aes(x=as.character(date), y=slope, color=category))

d %>%
  filter(category == 'Ctrl.H' | category == 'Ctrl.D') %>% ggplot() + geom_point(aes(x=treatment, y=slope, color=treatment)) + facet_wrap(vars(date))

```

Outlier Hunt
```{r}
mean(d$slope)
median(d$slope)
min(d$slope)
max(d$slope)
```

Using a linear model to set a cutoff for the blanks which can then be used to remove the other outliers by predicting the blank values for every day.
```{r}
blanks <-  d %>% filter(category == 'Blank')
blanks %>% ggplot() + geom_point(aes(x=slope, y=1)) +
  scale_x_log10()

# setting cutoff for blanks around 
bad.blanks <- blanks %>% filter(slope > 0.05)
good.blanks <- blanks %>% filter(slope < 0.05)

model <- lmer(slope~(1|date), data = good.blanks)
dates.predict <- data.frame(date=distinct(d, date))
# dates.predict$batch <- c(rep(1,4), rep(2,4))
dates.predict$null = predict(model, dates.predict)
```


Checking for effects of time
```{r}
d %>% filter(date == ymd(20230505)) %>% filter(well=='J15')
d %>% ggplot() +
  geom_histogram(aes(x=time))
```


Outlier Analysis
```{r}
data <- d %>% 
  filter(initial <= final) %>% 
  anti_join(bad.blanks) %>%
  full_join(dates.predict, by=join_by(date)) %>%
  filter(slope >= null) %>%
  filter(!(treatment %in% anc.hap.fake))


diff <- anti_join(d, data)
diff %>% filter(date == ymd(20230503)) %>% select(well) %>% as.vector()
diff %>% filter(date == ymd(20230505)) %>% select(well) %>% as.vector()
diff %>% filter(date == ymd(20230428)) %>% select(well) %>% as.vector()
diff %>% filter(date == ymd(20230430)) %>% select(well) %>% as.vector()
```


Data Analysis
```{r}
data <- data %>% select(date, well, treatment, label, category, slope, initial) %>%
  filter(category != 'Blank')
data$ploidy <- case_when(
  data$category %in% c('Ctrl.H', 'MA.H') ~ 'Haploid',
  data$category %in% c('Ctrl.D', 'MA.D') ~ 'Diploid'
)
data$MA <- case_when(
  data$category %in% c('MA.H', 'MA.D') ~ 'MA',
  data$category %in% c('Ctrl.H', 'Ctrl.D') ~ 'Ctrl',
)

```

Relative fitness calculations for every line by using lmer predictions for both ancestors and MA lines. This is a slightly questionable approach but doesn't hurt to try
```{r}
trt <- data %>% filter(label > 0 & label <= 100)
ctrl <- data %>% filter(label > 100)

mod <- lm(slope ~ ploidy, ctrl)
ctrl.predict <- data.frame(distinct(ctrl, ploidy))
ctrl.predict$ctrl <- predict(mod, ctrl.predict)

mod2 <- lm(slope ~ label, trt)
trt.predict <- data.frame(distinct(trt, label, ploidy))
trt.predict$trt <- predict(mod2, trt.predict)

trt.predict <- left_join(trt.predict, ctrl.predict, by=c('ploidy'))
trt.predict$rel.fit <- trt.predict$trt - trt.predict$ctrl

mu.dip <- mean(trt.predict$rel.fit[trt.predict$ploidy == 'Diploid'])
sd.dip <- sd(trt.predict$rel.fit[trt.predict$ploidy == 'Diploid'])

mu.hap <- mean(trt.predict$rel.fit[trt.predict$ploidy == 'Haploid'])
sd.hap <- sd(trt.predict$rel.fit[trt.predict$ploidy == 'Haploid'])


trt.predict %>% ggplot() +
  geom_histogram(aes(x=rel.fit), fill='black') +
  facet_grid(rows = vars(ploidy)) +
  geom_vline(data = data.frame(ploidy = c('Haploid', 'Diploid'),
                               mu = c(mu.hap, mu.dip)),
             aes(xintercept = mu, color = ploidy)) +
  geom_vline(xintercept = 0, color = 'black') +
  xlab("Relative Fitness") +
  ylab("Number of Lines") +
  guides(color = guide_legend(title = "Ploidy"))


```


Relative fitness calculations
```{r}
trt <- data %>% filter(label > 0 & label <= 100)
ctrl <- data %>% filter(label > 100)

mod <- lmer(slope ~ ploidy + (1|date), ctrl)
ctrl.predict <- data.frame(distinct(ctrl, date, ploidy))
ctrl.predict$ctrl <- predict(mod, ctrl.predict)
trt <- left_join(trt, ctrl.predict, by=c('date', 'ploidy'))
trt$rel.fit <- trt$slope - trt$ctrl

trt <- trt %>% group_by(ploidy, label) %>%
  summarize(rel.fit = median(rel.fit)) %>%
  ungroup()

mu.dip <- mean(trt$rel.fit[trt$ploidy == 'Diploid'])
sd.dip <- sd(trt$rel.fit[trt$ploidy == 'Diploid'])

mu.hap <- mean(trt$rel.fit[trt$ploidy == 'Haploid'])
sd.hap <- sd(trt$rel.fit[trt$ploidy == 'Haploid'])


trt %>% ggplot() +
  geom_histogram(aes(x=rel.fit), fill='black') +
  facet_grid(rows = vars(ploidy)) +
  geom_vline(data = data.frame(ploidy = c('Haploid', 'Diploid'),
                               mu = c(mu.hap, mu.dip)),
             aes(xintercept = mu, color = ploidy)) +
  geom_vline(xintercept = 0, color = 'black') +
  xlab("Relative Fitness") +
  ylab("Number of Lines") +
  guides(color = guide_legend(title = "Ploidy"))
```


```{r}
vioplot(trt[trt$ploidy == 'Haploid',]$rel.fit,
        trt[trt$ploidy == 'Diploid',]$rel.fit,
        names = c("Haploid", "Diploid"),
        col = c('red', 'blue'))
abline(a=0, b=0)
```


lmer for hypothesis testing
```{r}
null <- lmer(slope ~ MA + ploidy + (1|date) + (1|treatment), data)
summary(null)
full <- lmer(slope ~ MA*ploidy + (1|date) + (1|treatment), data)
summary(full)

mod <- anova(null, full)
mod


full <- lmer(slope ~ MA + (1|date) + (1|treatment), data)
null <- lmer(slope ~ 1 + (1|date) + (1|treatment), data)
mod <- anova(null, full)
mod

full <- lmer(slope ~ ploidy + (1|date) + (1|treatment), data)
null <- lmer(slope ~ 1 + (1|date) + (1|treatment), data)
mod <- anova(null, full)
mod

#2023 10 30
full <- lmer(slope ~ MA + ploidy + (1|date) + (1|treatment), data)
null <- lmer(slope ~ MA + (1|date) + (1|treatment), data)
mod <- anova(null, full)
mod

full <- lmer(slope ~ ploidy + MA + (1|date) + (1|treatment), data)
null <- lmer(slope ~ ploidy + (1|date) + (1|treatment), data)
mod <- anova(null, full)
mod



#old
full <- lmer(slope ~ ploidy + (1|date) + (1|treatment), data[data$MA == 'MA',])
summary(full)
null <- lmer(slope ~ 1 + (1|date) + (1|treatment), data[data$MA == 'MA',])
mod <- anova(null, full)
mod


#2023 10 26
full <- lmer(slope ~ ploidy + (1|date) + (1|treatment), data[data$MA == 'MA',])
summary(full)
null <- lmer(slope ~ ploidy + (1|date), data[data$MA == 'MA',])
mod <- anova(null, full)
mod


full.hap <- lmer(slope ~ 1 + (1|date) + (1|treatment), data[data$MA == 'MA' & data$ploidy =='Haploid',])
null.hap <- lmer(slope ~ 1 + (1|date), data[data$MA == 'MA' & data$ploidy =='Haploid',])
anova(full.hap, null.hap)

full.hap <- lmer(slope ~ 1 + (1|date) + (1|treatment), data[data$MA == 'Ctrl' & data$ploidy =='Haploid',])
null.hap <- lmer(slope ~ 1 + (1|date), data[data$MA == 'Ctrl' & data$ploidy =='Haploid',])
anova(full.hap, null.hap)



full.dip <- lmer(slope ~ 1 + (1|date) + (1|treatment), data[data$MA == 'MA' & data$ploidy =='Diploid',])
confint(full.hap)
confint(full.dip)
confint.merMod(full.hap) # or just use confint
confint.merMod(full.dip)
mod


#old
full <- lmer(slope ~ ploidy + (1|date) + (1|treatment), data[data$MA == 'Ctrl',])
summary(full)
null <- lmer(slope ~ 1 + (1|date) + (1|treatment), data[data$MA == 'Ctrl',])
mod <- anova(null, full)
mod
```

More exploration

Checking consistency of lines
```{r}
data %>% filter(treatment != 'H1') %>%
  filter(treatment != 'H3') %>% 
  ggplot() + geom_point(aes(x=treatment, y=slope, color=treatment))
```

Summarize all collected data for all lines and calculate parameters
```{r}
df <- data %>% 
  group_by(treatment, ploidy, MA) %>%
  summarize(avg = mean(slope),
            var = var(slope),
            sd = sd(slope),
            min = min(slope),
            min.date = data$date[data$slope == min(data$slope)],
            max = max(slope),
            max.date = data$date[data$slope == max(data$slope)]) %>%
  ungroup()
```

Trying some exploratory plots for variance
```{r}
df %>% ggplot() + geom_histogram(aes(x=var), fill = 'black')
df %>% filter(var > 0.0025)
df %>% ggplot() + geom_histogram(aes(x=sd), fill = 'black')

df %>% ggplot() + geom_histogram(aes(x=avg), fill = 'black') +
  geom_vline(xintercept = df$avg[df$ploidy == 'Haploid' &
                               df$MA == 'Ctrl'], color='Red') +
  geom_vline(xintercept = df$avg[df$ploidy == 'Diploid' &
                               df$MA == 'Ctrl'], color='Blue')
df %>% filter(avg > 0.2)

df %>% ggplot() + geom_histogram(aes(x=var), fill = 'black') +
  geom_vline(xintercept = df$var[df$ploidy == 'Haploid' &
                               df$MA == 'Ctrl'], color='Red') +
  geom_vline(xintercept = df$var[df$ploidy == 'Diploid' &
                               df$MA == 'Ctrl'], color='Blue')
```

Trying lmer models with variance and sd
```{r}
mod <- lm(var ~ ploidy*MA, df)
summary(mod)

mod <- lm(var ~ ploidy, df[df$MA == 'Ctrl',])
summary(mod)

mod <- lm(var ~ ploidy, df[df$MA == 'MA',])
summary(mod)

mod <- lm(var ~ MA, df[df$ploidy == 'Haploid',])
summary(mod)

mod <- lm(var ~ MA, df[df$ploidy == 'Diploid',])
summary(mod)
```

```{r}
trt <- data %>% filter(label > 0 & label <= 100)
ctrl <- data %>% filter(label > 100)

mod <- lmer(slope ~ ploidy + (1|date), ctrl)
ctrl.predict <- data.frame(distinct(ctrl, date, ploidy))
ctrl.predict$ctrl <- predict(mod, ctrl.predict)
trt <- left_join(trt, ctrl.predict, by=c('date', 'ploidy'))
trt$rel.fit <- trt$slope - trt$ctrl

```

Data Cleanup for d2 (does not exclude ploidy changes)

```{r}
d2 <- d2 %>% mutate(category = ifelse(label %in% fake.diploids, 'MA.H', category))
d2 <- d2 %>% mutate(category = ifelse(label %in% fake.haploids, 'MA.D', category))
d2 <- d2 %>% filter(batch == 2)
data2 <- d2 %>% 
  filter(initial <= final) %>% 
  anti_join(bad.blanks) %>%
  full_join(dates.predict, by=join_by(date)) %>%
  filter(slope >= null) %>%
  filter(!(treatment %in% anc.hap.fake))

data2 <- data2 %>% select(date, well, treatment, label, category, slope, initial) %>%
  filter(category != 'Blank')
data2$ploidy <- case_when(
  data2$category %in% c('Ctrl.H', 'MA.H') ~ 'Haploid',
  data2$category %in% c('Ctrl.D', 'MA.D') ~ 'Diploid'
)
data2$MA <- case_when(
  data2$category %in% c('MA.H', 'MA.D') ~ 'MA',
  data2$category %in% c('Ctrl.H', 'Ctrl.D') ~ 'Ctrl',
)

trt2 <- data2 %>% filter(label > 0 & label <= 100)
ctrl2 <- data2 %>% filter(label > 100)

# Try filtering based on the control info
ctrl2 <- ctrl2 %>% filter(treatment != 'H1') %>%
  filter(treatment != 'H3')
ctrl2 %>% ggplot() +
  geom_point(aes(x=slope, y=treatment))


# previous code
mod2 <- lmer(slope ~ ploidy + (1|date), ctrl2)
ctrl.predict2 <- data.frame(distinct(ctrl, date, ploidy))
ctrl.predict2$ctrl <- predict(mod2, ctrl.predict2)
trt2 <- left_join(trt2, ctrl.predict2, by=c('date', 'ploidy'))
trt2$rel.fit <- trt2$slope - trt2$ctrl
trt2 <- trt2 %>% group_by(ploidy, label) %>%
  summarize(rel.fit = mean(rel.fit)) %>%
  ungroup()
```


Read the mutation data and work with that
```{r}
mut <- read_delim("pombe_MA_data.txt")
trt2 <- trt2 %>%
  left_join(mut, by=c('label'='line'))
trt2 <- trt2 %>% select(ploidy.x, label, rel.fit, ploidy.y, ploidy_final,
                        n.SNM, n.indel)
trt2 <- trt2 %>% mutate(mutations = n.SNM + n.indel)

trt2 %>% ggplot() +
  geom_point(aes(x=mutations , y=rel.fit, color=ploidy.x)) +
  geom_smooth(data=trt2[trt2$ploidy.x == 'Haploid',],
              mapping=aes(x=mutations, y=rel.fit), color='Blue', method="lm", se=FALSE) +
  geom_smooth(data=trt2[trt2$ploidy.x == 'Diploid',],
              mapping=aes(x=mutations, y=rel.fit), color='Red', method="lm", se=FALSE)

trt2 %>% ggplot() +
  geom_point(aes(x=n.SNM, y=rel.fit)) +
  geom_smooth(aes(x=n.SNM, y=rel.fit), method = "lm", se=FALSE, color='blue')

trt2 %>%
  filter(ploidy.x == 'Haploid') %>% ggplot() +
  geom_point(aes(x=n.SNM, y=rel.fit)) +
  geom_smooth(aes(x=n.SNM, y=rel.fit), method = "lm", se=FALSE, color='blue')

trt2 %>%
  filter(ploidy.x == 'Diploid') %>% ggplot() +
  geom_point(aes(x=n.SNM, y=rel.fit)) +
  geom_smooth(aes(x=n.SNM, y=rel.fit), method = "lm", se=FALSE, color='blue')

trt2 %>% ggplot() +
  geom_point(aes(x=n.indel, y=rel.fit)) +
  geom_smooth(aes(x=n.indel, y=rel.fit), method = "lm", se=FALSE, color='blue')

trt2 %>%
  filter(ploidy.x == 'Haploid') %>% ggplot() +
  geom_point(aes(x=n.indel, y=rel.fit)) +
  geom_smooth(aes(x=n.indel, y=rel.fit), method = "lm", se=FALSE, color='blue')

trt2 %>%
  filter(ploidy.x == 'Diploid') %>% ggplot() +
  geom_point(aes(x=n.indel, y=rel.fit)) +
  geom_smooth(aes(x=n.indel, y=rel.fit), method = "lm", se=FALSE, color='blue')

```

```{r}
mod <- lm(trt2$rel.fit ~ trt2$n.SNM)
summary(mod)

mod <- lm(trt2$rel.fit ~ trt2$n.indel)
summary(mod)

mod.hap <- lm(rel.fit ~ mutations, trt2[trt2$ploidy.x=='Haploid',])
summary(mod.hap)

mod.dip <- lm(rel.fit ~ mutations, trt2[trt2$ploidy.x=='Diploid',])
summary(mod.dip)
```



```{r}
trt2 %>% ggplot() +
  geom_histogram(aes(x=rel.fit), fill='black') +
  facet_grid(rows = vars(ploidy.x)) +
  geom_vline(data = data.frame(ploidy.x = c('Haploid', 'Diploid'),
                               mu = c(mu.hap, mu.dip)),
             aes(xintercept = mu, color = ploidy.x)) +
  geom_vline(xintercept = 0, color = 'black') +
  xlab("Relative Fitness") +
  ylab("Number of Lines") +
  guides(color = guide_legend(title = "Ploidy"))
```

lmer for hypothesis testing
```{r}
null <- lmer(slope ~ MA + ploidy + (1|date) + (1|treatment), data)
summary(null)
full <- lmer(slope ~ MA*ploidy + (1|date) + (1|treatment), data)
summary(full)

mod <- anova(null, full)
mod


full <- lmer(slope ~ ploidy + (1|date) + (1|treatment), data2[data2$MA == 'MA',])
summary(full)
null <- lmer(slope ~ 1 + (1|date) + (1|treatment), data2[data2$MA == 'MA',])
mod <- anova(null, full)
mod

full <- lmer(slope ~ ploidy + (1|date) + (1|treatment), data2[data2$MA == 'Ctrl',])
summary(full)
null <- lmer(slope ~ 1 + (1|date) + (1|treatment), data2[data2$MA == 'Ctrl',])
mod <- anova(null, full)
mod
```

Trying more lmer
```{r}
full <- lmer(slope ~ initial + (1|ploidy) + (1|MA) + (1|treatment) + (1|date), data2)
summary(full)
null <- lmer(slope ~ 1 + (1|ploidy) + (1|MA) + (1|treatment) + (1|date), data2)
anova(full, null)

full <- lmer(slope ~ ploidy + (1|initial) + (1|MA) + (1|treatment) + (1|date), data2)
summary(full)
null <- lmer(slope ~ 1 + (1|initial) + (1|MA) + (1|treatment) + (1|date), data2)
anova(full, null)

full <- lmer(slope ~ MA + (1|ploidy) + (1|initial) + (1|treatment) + (1|date), data2)
summary(full)
null <- lmer(slope ~ 1 + (1|ploidy) + (1|initial) + (1|treatment) + (1|date), data2)
anova(full, null)

# Date, fortunately does not have a significant effect
full <- lmer(slope ~ date + (1|ploidy) + (1|initial) + (1|MA) + (1|treatment), data2)
summary(full)
null <- lmer(slope ~ 1 + (1|ploidy) + (1|initial) + (1|MA) + (1|treatment), data2)
anova(full, null)

full <- lmer(slope ~ ploidy * MA + initial + (1|treatment) + (1|date), data)
summary(full)
null <- lmer(slope ~ ploidy + MA + initial + (1|treatment) + (1|date), data)
anova(full, null)


```


Plots for poster
```{r}
d2 %>% ggplot() +
  geom_point(aes(x = category, y = slope)) +
  xlab("Lines") +
  ylab("Maximum Growth Rate") +
  scale_x_discrete(labels = c("Ctrl.D" = "Dip-Ctrl",
                   "Ctrl.H" = "Hap-Ctrl",
                   "MA.D" = "Dip-MA",
                   "MA.H" = "Hap-MA"))


data2 %>% ggplot() +
  geom_point(aes(x = category, y = slope)) + 
  xlab("Lines") +
  ylab("Maximum Growth Rate") + 
  scale_x_discrete(labels = c("Ctrl.D" = "Dip-Ctrl",
                   "Ctrl.H" = "Hap-Ctrl",
                   "MA.D" = "Dip-MA",
                   "MA.H" = "Hap-MA"))

vioplot(trt2[trt2$ploidy.x == 'Haploid',]$rel.fit,
        trt2[trt2$ploidy.x == 'Diploid',]$rel.fit,
        names = c("Haploid", "Diploid"),
        col = c('red', 'blue'),
        ylim = c(-0.15, 0.01), 
        ylab = "Relative Fitness",
        xlab = "Ploidy")
abline(h=0)

mu.dip2 <- mean(trt2$rel.fit[trt2$ploidy.x == 'Diploid'])
sd.dip2 <- sd(trt2$rel.fit[trt2$ploidy.x == 'Diploid'])

mu.hap2 <- mean(trt2$rel.fit[trt2$ploidy.x == 'Haploid'])
sd.hap2 <- sd(trt2$rel.fit[trt2$ploidy.x == 'Haploid'])

trt2 %>% ggplot() +
  geom_histogram(aes(x=rel.fit), fill='black') +
  facet_grid(rows = vars(ploidy.x)) +
  geom_vline(data = data.frame(ploidy.x = c('Haploid', 'Diploid'),
                               mu = c(mu.hap2, mu.dip2)),
             aes(xintercept = mu, color = ploidy.x), show.legend = FALSE) +
  geom_vline(xintercept = 0, color = 'black') +
  xlab("Relative Fitness") +
  ylab("Number of Lines") 
  # guides(color = guide_legend(title = "Mean Relative Fitness"))

trt2 %>% ggplot() +
  geom_point(aes(x=mutations , y=rel.fit, color=ploidy.x)) +
  geom_smooth(data=trt2[trt2$ploidy.x == 'Haploid',],
              mapping=aes(x=mutations, y=rel.fit), color='Blue', method="lm", se=FALSE) +
  geom_smooth(data=trt2[trt2$ploidy.x == 'Diploid',],
              mapping=aes(x=mutations, y=rel.fit), color='Red', method="lm", se=FALSE) +
  ylab("Relative Fitness") +
  xlab("Number of Mutations (SNM + indel)") +
  guides(color = guide_legend(title = "Ploidy"))

```


Understanding my controls
```{r}
c <- bind_rows(dfs)

blanks <-  c %>% filter(treatment == 'Blank')

# setting cutoff for blanks around 
good.blanks <- blanks %>% filter(slope < 0.05)
bad.blanks <- blanks %>% filter(slope > 0.05)

model <- lmer(slope~(1|date), data = good.blanks)
dates.predict <- data.frame(date=distinct(d, date))
dates.predict$null = predict(model, dates.predict)

c <- anti_join(c, bad.blanks)
c <- full_join(c, dates.predict, by=join_by(date))
c <- c %>% filter(slope >= null)

c$delta <- c$final - c$initial
c <- c %>% filter(delta >= 0)

control <- c('H1', 'H2', 'H3', 'D1', 'D2', 'D3', 'C1', 'C3')
c <- c %>% filter(treatment %in% control)
c <- c %>% filter(date %in% dates.2)
c <- c %>% mutate(group = ifelse(date == mdy(11022023), 'new', 'original'))

c %>% ggplot() +
  geom_point(aes(x=treatment, y=slope, color=group), alpha=0.7)



```










