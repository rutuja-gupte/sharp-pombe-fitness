---
title: "MA Fitness"
author: "Rutuja Gupte"
date: "2023-09-21"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

---
title: "MA Fitness"
author: "Dr Nathaniel Sharp"
---

- this fits a spline to y=OD versus x=time, and then finds the maximum slope
```{r}
spline.slope<-function(x, y, n=101, eps=1e-5, span=0.2){
  max(nderiv(loess(log(y) ~ x, degree=1, span=span), seq(min(x), max(x), length=n)), na.rm=TRUE)
}
```

- used by the function above to get a local (linear) slope around a point

```{r}
nderiv <- function(fit, x, eps=1e-5){
  (predict(fit, x + eps) - predict(fit, x - eps))/(2 * eps)}

```

---
title: "MA Fitness"
author: "Rutuja Gupte"
---

Import Statements
```{r}
library(dplyr)
library(stringr)
library(tidyverse)
library(lme4)
```

- this fits a spline to y=OD versus x=time, and then finds the time-stamp for maximum slope
```{r}
spline.time<-function(x, y, n=101, eps=1e-5, span=0.2){
  which.max(nderiv(loess(log(y) ~ x, degree=1, span=span), seq(min(x), max(x), length=n)))
}
```

- this fits a linear regression model and extracts the slope
```{r}
well.lm <- function(x, y){
  lm(y ~ x)$coefficients[2]
}
```

- this fits a linear regression model and extracts the p value
```{r}
well.lm.p <- function(x, y){
  lm(y ~ x)$coefficients[2,4]
}
```

Load all files and setup variables
```{r}
l <- list.files()

# read all data into a list of data frames
dfs <- lapply(l[endsWith(l, '.csv')], function(r){
  d <- read.csv(r)
  
  assay.name <- str_replace(str_replace(r, 'Ref', 'Rutuja'), '.csv', '.txt')
  assay.data <- read.delim(assay.name)
  # Change time column to 0, 0.25, 0.5, ...
  assay.data$Time<-seq(from=0.25,by=0.25,length.out=nrow(assay.data))
  # calculate slopes
  d$slope <- sapply(c(1:nrow(d)), function(r){
    spline.slope(assay.data$Time, assay.data[,which(names(assay.data)==d$well[r])])
  })
  
  # calculate time stamps for max slop
  d$time <- sapply(c(1:nrow(d)), function(r){
    spline.time(assay.data$Time, assay.data[,which(names(assay.data)==d$well[r])])
  })
  
  d$lm <- sapply(c(1:nrow(d)), function(r){
    well.lm(assay.data$Time, assay.data[,which(names(assay.data)==d$well[r])])
  })
  
  d$p <- sapply(c(1:nrow(d)), function(r){
    well.lm(assay.data$Time, assay.data[,which(names(assay.data)==d$well[r])])
  })
  
  d$time <- assay.data$Time[d$time]
  
  d$date <- mdy(str_replace(str_replace(r, 'Ref ', ''), '.csv', ' 2023'))
  return(d)
})

# merge the list of data frames
d <- dfs %>% reduce(bind_rows)

dates.1 <- seq(mdy(04062023), mdy(04102023), 1)
dates.2 <- seq(mdy(04282023), mdy(05052023), 1)
ancestors <- c('H1', 'H2', 'H3', 'D1', 'D2', 'D3')
# these are all the haploid ancestors including the diploids that are supposed to be diploids
ancestors.haploid <- c('H1', 'H2', 'H3', 'D2', 'D3')
# these are haploids that were intended to be haploids
anc.hap.og <- c('H1', 'H2', 'H3')
# these are haploids that were intended to be diploids
anc.hap.fake <- c('D2', 'D3')
# this is the only actual diploid control that was diploid
ancestors.diploid <- c('D1')
# this MA line started out as a haploid but ended up as a diploid
fake.haploids <- c(81)
# these MA lines started out as diploids but ended up as haploids
fake.diploids <- c(20, 28, 48, 52, 54, 84, 100)
```

Adding additional information for categorization
```{r}
d$batch[d$date %in% dates.1] <- 1
d$batch[d$date %in% dates.2] <- 2
d$label <- d$treatment
d$label[d$treatment == 'Blank'] <- '0'
d$label[d$treatment == 'H1'] <- '101'
d$label[d$treatment == 'D1'] <- '102'
d$label[d$treatment == 'H2'] <- '103'
d$label[d$treatment == 'D2'] <- '104'
d$label[d$treatment == 'H3'] <- '105'
d$label[d$treatment == 'D3'] <- '106'
d$label <- as.numeric(d$label)

d <- d %>% mutate(category = case_when(label == 0 ~ 'Blank',
                              label > 100 & treatment %in% ancestors.haploid ~ 'Ctrl.H',
                              label > 100 & treatment %in% ancestors.diploid ~ 'Ctrl.D',
                              label %% 2 == 0 ~ 'MA.D',
                              label %% 2 == 1 ~ 'MA.H'))

# exclude the haploid and diploid MA lines that switched ploidy for now
d <- d %>% filter(!(label %in% fake.diploids)) %>%
  filter(!(label %in% fake.haploids))
# d <- d %>% mutate(category = ifelse(label %in% fake.diploids, 'MA.H', category))
# d <- d %>% mutate(category = ifelse(label %in% fake.haploids, 'MA.D', category))

d <- d %>% filter(batch == 2)
```


Use dates before taking averaging to check for day effects
```{r}
# d %>% ggplot() + geom_point(aes(x=as.character(date), y=slope, color=category))

d %>% ggplot() + geom_point(aes(x=category, y=slope, color=category)) + facet_wrap(vars(date))
```

Outlier Hunt
```{r}
d %>% slice_min(order_by = slope, n=30)
mean(d$slope)
median(d$slope)
min(d$slope)
max(d$slope)

# d %>% filter(slope < 0.025) %>%
#   count(date)
# 
# d %>% filter(slope < 0.005) %>% count(treatment)
# 
# d %>% filter(slope < 0.005) %>%
#   ggplot() + geom_point(aes(x=slope, y=1))
# 
# mean(d$slope < 0.025 & d$treatment != 'Blank')
# quantile(d$slope, 0.06119792)
# 
# 
# d %>% filter(slope < 0.010) %>%
#   filter(date == dmy(06042023)) %>% ggplot() +
#   geom_point(aes(x=slope, y=1))

```

Trial plot after removing outliers
```{r}
d %>% filter(slope > 0.010) %>% ggplot() + geom_point(aes(x=category, y=slope, color=category)) + facet_wrap(vars(date))
```

Trying a linear model to set a cutoff for the blanks which can then be used to remove the other outliers
```{r}
blanks <-  d %>% filter(category == 'Blank')
blanks %>% ggplot() + geom_point(aes(x=slope, y=1)) +
  scale_x_log10()

# setting cutoff for blanks around 
bad.blanks <- blanks %>% filter(slope > 0.05)
good.blanks <- blanks %>% filter(slope < 0.05)

model <- lmer(slope~(1|date), data = good.blanks)
dates.predict <- data.frame(date=distinct(d, date))
# dates.predict$batch <- c(rep(1,4), rep(2,4))
dates.predict$null = predict(model, dates.predict)
```

Trial plot to see whether this will work
```{r}
ggplot() + geom_point(data=d, aes(x=category, y=slope, color=category)) + 
   facet_wrap(vars(date)) +
  geom_hline(yintercept=dates.predict$null) + facet_wrap(vars(dates.predict$date))
```

Remove the outlier blanks and the other blanks from the actual data
```{r}
df <- anti_join(d, bad.blanks)
df <- full_join(df, dates.predict, by=join_by(date))
df <- df %>% filter(slope > null)
```

Plot the date yet again
```{r}
df %>% ggplot() + geom_point(aes(x=category, y=slope, color=category)) + facet_wrap(vars(date))
```

Trying new approach for removing outliers. Instead of using the lmer, compare with the max values for the blanks for each date

Compute maximum values for the blanks for each date
```{r}
dates.predict2 <- good.blanks %>% select(date, slope) %>% group_by(date) %>% summarize(null = max(slope))
```

Remove the outlier blanks and the other blanks from the actual data
```{r}
df2 <- anti_join(d, bad.blanks)
df2 <- full_join(df2, dates.predict2, by=join_by(date))
df2 <- df2 %>% filter(slope > null)
```

Plot the date yet again
```{r}
df %>% ggplot() + geom_point(aes(x=category, y=slope, color=category)) + facet_wrap(vars(date))
```

Finding the difference between the two outlier methods
```{r}
diff <- anti_join(df, df2, by=join_by(well, date))
diff %>% select(well, date) %>% count(date)

diff %>% filter(date == dmy(28042023)) %>% select(well)
diff %>% filter(date == dmy(30042023)) %>% select(well)
diff %>% filter(date == dmy(05052023)) %>% select(well)
```

> Important Note: The 15 curves that are different between the two approaches are all bad curves (based on their plots). I would prefer to exclude those.

Sampling few low curves from df2 to see their shape. Shape plotting in plotting python notebook.
```{r}
df2 %>%
  filter(date == dmy(03052023)) %>% 
  slice_min(order_by = slope, n=8) %>% select(well)

df2 %>% 
  filter(date == dmy(05052023)) %>%
  slice_min(order_by = slope, n=8) %>% select(well)

df2 %>% 
  filter(date == dmy(28042023)) %>%
  slice_min(order_by = slope, n=8) %>% select(well)

df2 %>% 
  filter(date == dmy(30042023)) %>%
  slice_min(order_by = slope, n=8) %>% select(well)
```

> More filtering required on the data...

```{r}
df2 %>% ggplot() + geom_point(aes(x=category, y=time, color=category)) + facet_wrap(vars(date))
```

```{r}
df2 %>% ggplot() + geom_histogram(aes(x=time), fill='black')
```

Filtering based on slope of linear model
```{r}
df2 <- df2 %>% filter(lm >= 0)
```

Filtering on how well linear model fits
```{r}
df2 %>% ggplot() + geom_histogram(aes(x=p), fill='black')
```











Calculate the average slope by grouping by date. Then use those averages from ancestors to calculate the average relative fitness for each 
```{r}
# df2 <- d %>% group_by(date, label) %>%
#   summarize(fit = mean(slope)) %>% 
#   mutate(category = case_when(label == 0 ~ 'Blank',
#                               label > 100 & label %% 2 == 0 ~ 'Diploid',
#                               label > 100 & label %% 2 == 1 ~ 'Haploid',
#                               label %% 2 == 0 ~ 'D',
#                               label %% 2 == 1 ~ 'H'))
# 
# df.ancestors <- df2 %>% filter(label > 100) %>%
#   group_by(date, category) %>% summarize(avg.fit = mean(fit)) %>% 
#   group_by(date) %>% summarize(hap=mean(avg.fit[category=='Haploid']), dip=mean(avg.fit[category=='Diploid'])) %>% as.data.frame()
# row.names(df.ancestors) <- df.ancestors$date
# 
# df2$a.fit <- apply(df, 1, function(r){
#   if(r['category'] %in% c('Haploid', 'H')) {
#     coln = 'hap'
#   } 
#   else if(r['category'] %in% c('Diploid', 'D')) {
#     coln = 'dip'
#   }
#   else {coln = 'NA'}
#   return(as.numeric(df.ancestors[r['date'], coln]))
# })
# 
# df2$a.fit <- as.numeric(df$a.fit)
# df2 <- df2 %>% mutate(rel.fit = ifelse(label == 0, fit, fit/a.fit))
# df2 <- df2 %>% mutate(rel.fit2 = ifelse(label == 0, fit, fit-a.fit))
```

Plot the relative fitness
```{r}
# df2 %>% filter(category != 'Blank') %>% ggplot() +
#   geom_histogram(aes(x=rel.fit, fill=category)) +
#   facet_grid(rows = vars(category)) +
#   geom_vline(xintercept=1, color='red')
```

Plot the relative fitness
```{r}
# df2 %>% filter(category != 'Blank') %>% ggplot() +
#   geom_histogram(aes(x=rel.fit2, fill=category)) +
#   facet_grid(rows = vars(category)) +
#   geom_vline(xintercept=0, color='red')
```

t test for mutants
```{r}
# mut.hap <- df2$rel.fit[df$category == 'H']
# mut.dip <- df2$rel.fit[df$category == 'D']
# 
# t.test(mut.hap, mu=1)
# t.test(mut.dip, mu=1)
```

t test for mutants
```{r}
# mut.hap <- df2$rel.fit2[df$category == 'H']
# mut.dip <- df2$rel.fit2[df$category == 'D']
# 
# t.test(mut.hap, mu=0)
# t.test(mut.dip, mu=0)
```


two sample t test comparing max slopes of ancestors and mutants
```{r}
# all.mut.hap <- d %>% filter(d$category == 'H') %>% select(slope)
# all.anc.hap <- d %>% filter(d$category == 'Haploid') %>% select(slope)
# 
# t.test(all.mut.hap, all.anc.hap, var.equal = FALSE)
```

```{r}
# all.mut.dip <- d %>% filter(d$category == 'D') %>% select(slope)
# all.anc.dip <- d %>% filter(d$category == 'Diploid') %>% select(slope)
# 
# t.test(all.mut.dip, all.anc.dip, var.equal = FALSE)
```


```{r}
# d.lmer <- d %>% filter(category != "Blank")
# d.lmer <- d.lmer %>% mutate(ancestry = ifelse(category %in% c('Haploid', 'Diploid'), 
#                                               'Ancestor', 'Mutant'))
# d.lmer <- d.lmer %>% mutate(ploidy = ifelse(category %in% c('Haploid', 'H'), 
#                                               'Haploid', 'Diploid'))
```

lmer from lme4 package
```{r}
# null.model <- lmer(slope~ancestry+ploidy+(1|date)+(1|label), d.lmer)
# full.model <- lmer(slope~ancestry*ploidy+(1|date)+(1|label), d.lmer)
# 
# mod <- anova(null.model,full.model)
# mod
```


lmer from lme4 package with plate placement
```{r}
# null.model <- lmer(slope~ancestry+ploidy+(1|date)+(1|well), d.lmer)
# full.model <- lmer(slope~ancestry*ploidy+(1|date)+(1|well), d.lmer)
# 
# mod <- anova(null.model,full.model)
# mod
```

lmer from lme4 package with Dr Sharp - ancestors
```{r}
# full.model <- lmer(slope~ploidy+(1|date)+(1|label), d.lmer[d.lmer$ancestry=='Ancestor',])
# null.model <- lmer(slope~1+(1|date)+(1|label), d.lmer[d.lmer$ancestry=='Ancestor',])
# 
# mod <- anova(null.model,full.model)
# mod
```

```{r}
# summary(full.model)
```


lmer from lme4 package with Dr Sharp - ancestors
```{r}
# full.model <- lmer(slope~1+(1|date)+(1|label), d.lmer[d.lmer$category=='Haploid',])
# null.model <- lmer(slope~1+(1|date), d.lmer[d.lmer$category=='Haploid',])
# 
# mod <- anova(null.model,full.model)
# mod
```







